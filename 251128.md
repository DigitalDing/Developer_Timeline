# **Devlog – Linux Study Session + Sunday Clock-In Simulator Planning**

**Date:** November 28, 2025

Today was dedicated to sharpening my Linux fundamentals and laying the groundwork for one of my upcoming small-scale build projects: the **Sunday Clock-In Simulator**. The day was less about flashy output and more about deepening command-line intuition, cleaning up mental models, and preparing for a controlled mini-project to put new skills into practice.

---

## **Linux Study: Building Command-Line Competency**

Much of the day was spent understanding how Linux expects a developer to behave. Linux is unforgiving but consistent. Once I slowed down and approached it on its terms, things began to click.

### **Key Lessons**

* **Navigation is the foundation.**
  I reinforced the habit of checking my current directory (`pwd`) before running commands. Twice I caught myself issuing commands from the wrong place, which made the value of deliberate navigation impossible to ignore.

* **Everything is a file.**
  Processes, devices, configs, sockets—they all live somewhere in the filesystem. Learning that principle made directory structures feel far less random.

* **Permissions shape everything.**
  I dug into the meaning of `rwx` across user, group, and other, and saw how tools like `chmod` and `chown` intervene when something “mysteriously” refuses to run.

* **Linux is literal.**
  When something fails:

  1. The path is wrong
  2. Permissions are wrong
  3. The service isn’t running

  This three-layer model gave me a stable framework for debugging and reduced a lot of noise.

* **Service behavior and port exposure.**
  I studied how local servers actually behave on Linux, how firewalls influence what gets through, and how networking interacts with services—important later for my remote-access work.

Overall, the goal today wasn’t to master Linux, but to remove the fog. I now understand the terrain well enough that running a small project on Linux feels achievable instead of awkward.

---

## **Project Setup Insight**

I also explored typical Linux directory roles:

* `/etc`: system configuration
* `/usr/bin`: executables
* `/var/log`: logs
* `/home/<user>`: the workspace
* `/opt` and `/srv`: good candidates for project-level services

This gave me the structure I’ll need for the Sunday Clock-In Simulator to live as a lightweight Linux-friendly script or service.

---

# **Sunday Clock-In Simulator: Design Outline**

Sunday will be dedicated to building out a small simulator that mimics “clocking in,” tracking timestamps, and returning behavior consistent with a real punch-in system. The idea is simple: use Linux fundamentals to create a functional, system-aware tool.

### **Purpose**

1. Reinforce Linux command-line learning with a contained project.
2. Produce a real script/application I can store in GitHub.
3. Practice structuring a Linux-friendly project directory.
4. Build something that could later attach to APIs, scheduling systems, or logging dashboards.

---

## **Planned Features (Initial Version)**

### **1. Core Clock-In Mechanic**

* User runs a script (likely Bash or Python).
* Script records:

  * Current timestamp
  * Username
  * Host machine
  * A running log entry

Stored to a text or CSV file in `/home/<user>/clockin-sim/data/`.

### **2. Log Viewer**

* Command: `clockin view` (or equivalent)
* Prints the last N clock-ins with timestamps.

### **3. History Ledger**

* Append-only ledger for all “shifts.”
* No editing; only adds entries.
* Good practice for permissions: `chmod 644` on log files.

### **4. Optional Stretch Goals**

* A lightweight TUI (text UI) using Python’s `curses`.
* Systemd service to auto-log when the machine boots.
* Bash alias (`clockin`) added to `.bashrc`.
* A daily summary:

  ```bash
  ./clockin_summary
  ```
* Export log to CSV for later analysis.

---

## **Technical Plan for Sunday**

1. Initialize a new repo dedicated to the simulator.
2. Create a Linux-standard folder structure (`bin/`, `data/`, `logs/`, `scripts/`).
3. Write a basic clock-in script.
4. Test permissions, paths, and execution behavior.
5. Add documentation and examples.
6. Commit, push, and reflect in another devlog entry.

The entire exercise exists to turn today’s Linux study into something tangible.

---

# **Closing Note**

Today was the groundwork.
Sunday will be the build.
Linux is starting to feel less like an operating system and more like a set of instruments, and the Sunday Clock-In Simulator will be my first small composition using them.

---
