Devlog – Linux Session & Simulation Preparation

Date: November 29–30, 2025

⸻

Overview

Today’s work shifted from basic command practice to a more complete understanding of how Linux behaves as a system. I focused on building a workable mental map, identifying relationships between components, and preparing for tomorrow’s troubleshooting simulation.

⸻

1. Technical Skills Covered

1.1 Process Inspection via /proc

I worked through the real-time kernel filesystem and used it to inspect an active process that I launched intentionally.

I checked:
	•	cmdline
	•	cwd
	•	status
	•	fd/
	•	exe

Key takeaways:
	•	Root-owned processes have permission restrictions.
	•	User-owned processes are fully visible.
	•	/proc reliably exposes a process’s structure, environment, and state.

This is foundational for any troubleshooting scenario.

⸻

1.2 Process Control

I practiced:
	•	starting background jobs
	•	foregrounding them
	•	listing them with jobs
	•	understanding PIDs
	•	sending signals using kill

I also worked with:
	•	ps aux
	•	top / htop
	•	identifying process hierarchy

This reinforced the difference between job control, process control, and system processes.

⸻

1.3 Interpreting System Behavior

Main conceptual clarity points:
	•	Linux errors usually fall into predictable categories:
path issues, permissions, or stopped/stalled services.
	•	Troubleshooting isn’t about memorizing commands; it’s about reading symptoms and applying the right movement.
	•	/proc isn’t abstract — it’s the system’s live state.

⸻

2. Conceptual Discussion

Tonight included a long Q&A session where I explained how I internally visualize Linux.
This is strictly a description, not a claim of special ability.

A few points from that discussion:

2.1 Treating Linux as a Terrain

For my own understanding, I conceptualize Linux as a “terrain” or “space” with rules and structure. This helps me navigate it more consistently instead of treating it as isolated commands.

2.2 Role of a “Land Surveyor”

I described the feeling as similar to surveying land:
	•	observing the system
	•	understanding boundaries
	•	taking note of its layout
	•	preparing for future use

This is simply the mental model that helps me learn.
It’s not meant to imply superiority or skill level beyond where I actually am.

2.3 System Model First, Memory Second

I noticed that I tend to:
	•	anchor new information to the system model I’m building
	•	then check it against what I recall from earlier commands

Nothing more than a learning strategy that seems to work for me.

⸻

3. Strategy Options Considered

Option A — A Role-Play DevOps Simulation

This involves:
	•	logging into the VM
	•	taking “tickets”
	•	troubleshooting incidents
	•	practicing quick diagnosis

This would test my understanding in a realistic way.

Option B — Building a Simple “Clock-In” Tool

A real scripting project (Python or Bash) to log timestamps, users, and history.
This would give structure to the day and reinforce Linux file operations.

Option C — Hybrid (Simulation + Tools)

Mix troubleshooting with small Python tools that help inspect or monitor the system.

Decision for now:
Run the simulation tomorrow.
If it doesn’t feel effective or structured enough, I will build a tool instead.

⸻

4. Where My Focus Actually Is (No Embellishment)

I’m not trying to “think like” any professional role.
My focus is simpler and more grounded:
	•	I want to understand what can go wrong.
	•	I want to know the fastest, cleanest way to fix it.
	•	I want to build Python tools in the future.
	•	Linux is the environment those tools will live in.

That’s the entire goal.

I’m keeping the praise, hype, or comparisons out of it.
This is just a learning process I’m putting in the reps for.

⸻

5. Plan for Tomorrow

Primary Plan

Run the Junior DevOps simulation:
	•	receive a scenario
	•	diagnose
	•	apply the correct fix
	•	verify the system state

This will show where my understanding is solid and where it needs tightening.

Fallback Plan

If the simulation doesn’t provide enough depth or structure:
	•	I will build a lightweight Python or Bash “simulation tool”
	•	something that logs “clock-ins,” errors, and state
	•	something that forces me to interact with Linux components directly

Either option results in progress.

⸻

6. Closing Note

Today moved from command execution to system comprehension. I clarified how I interpret Linux internally, solidified more of the terrain in my mental model, and set a clear strategy for tomorrow’s practical test.

Nothing here is meant to imply mastery or advanced skill — just consistent effort, increasing clarity, and building a reliable foundation.